---
layout: post
title: Memory mangement in Python
permalink: /blogs/python
---

## Python Implementation

<p>Python is an interpreted & high-level language. It is dynamically typed & is used as a general-purpose language. The default python implementation is <b>CPython</b> & is written in C programming language.</p>

<p>The CPython converts your python code into computer-readable instructions called bytecode. These instructions are interpreted by a virtual machine when you run your code. The bytecode is stored in <b>.pyc</b> file in <b>__pycache__</b> folder.</p>

<p>Other python implementations available are: 
<ul>
  <li><b>Jython:</b> compiles down to Java bytecode to run on JVM (Java Virtual Machine)</li>
  <li><b>IronPython:</b> compiles down to run on Microsoft’s CLR (Common Language Runtime)</li>
  <li><b>PyPy:</b> uses JIT (Just-In-Time) compilation to translate python code into assembly language</li>
</ul>
</p>

<p>If you want to look at CPython's bytecode then you can. Here's how you can:</p>

  ![_config.yml]({{ site.baseurl }}/images/python/memory-management/Cpython_bytecode.png)
  
<p>
  Now, let's have a look at the above code. Lines 1 to 6 are a function definition. In line 8, we import the 'dis' module which can be used to view the intermediate Python bytecode (or you can say, disassembler for Python bytecode) that is generated by CPython (interpreter).
</p>

## Memory management

<p>
  In this article we are only going to talk about CPython implementation for memory management. As CPython is written in C language it does not natively support OOP. In Python, everything is an object, even int or str. CPython uses a struct called PyObject to store this information.
</p>

<p>
PyObject contains two things:
<ul>
  <li><b>ob_refcnt:</b> reference count</li>
  <li><b>ob_type:</b> pointer to another type</li>
</ul>
</p>

<p>The reference count increases whenever that object is referenced. For e.g.</p>

 ![_config.yml]({{ site.baseurl }}/images/python/memory-management/ref_cnt.png)
 
 <p>Here, the reference count of ‘198653’ is increased & decreased whenever it is being referenced or dereferenced by the variables.</p>
 
<p>
  <b>NOTE:</b> The reference count is starting with 3 because CPython internally keeps an already created integer object with value 1 and internal variables point to it.
</p>

<p>Whenever the reference count of an object reaches to 0. That object can be picked up by the garbage collector so that memory can be freed.</p>

<p>
  The OS provides virtual memory layer that applications like python can access. Python uses some portion for internal use & other portion is dedicated for object storage. CPython used an object allocator which gets called every time a new object is created or deleted. Internally the object allocator used C library’s malloc function for memory allocation. 
</p>

<p>
  There are 3 main pieces of CPython’s memory allocator:
  <ul>
    <li><b>Arenas</b></li>
    <li><b>Pools</b></li>
    <li><b>Blocks</b></li>
  </ul>
</p>

### Arenas

<p>
  Arenas are the largest chunks of memory. They are aligned on fixed-length contiguous chunk of memory that OS uses. Python assumes the system’s page size as 256KB. Arenas contains pools.
</p>

<p>
  They are organized into a doubly linked list called usable_arenas. This list is sorted by number of free pools available. Whenever memory is freed python doesn’t actually free the memory to OS it keeps it allocated & will use it for newer data. The arenas which are closer to being empty should be allowed to become empty so that chunk of memory can then be truly freed & can be given back to OS reducing the overall memory used by Python.
</p>

 ![_config.yml]({{ site.baseurl }}/images/python/memory-management/arenas.png)

### Pools

<p>
Pools are present inside arenas & have virtual memory of 4 KB. They are composed of blocks of a single size class. Each pool maintains a doubly linked list to other pools of same size class. The pools can be in the following states:
  <ul>
    <li><b>empty:</b> No data stored & any size class blocks can be assigned as per the need</li>
    <li><b>used:</b> Blocks for a particular size class are available to store data</li>
    <li><b>full:</b> All blocks are allocated & contain data</li>
  </ul>
</p>

<p>
  There are 2 types of lists used here:
  <ul>
    <li><b>freepools:</b> Keeps track of all the pools in empty state</li>
    <li><b>usedpools:</b> Keeps track of all the pools in used state</li>
  </ul>
</p>

<p>
  Now if a full pool frees some of its blocks then that pool will be added into the usedpools list of that particular size class. And if the program requires a memory chunk of some bytes & no pools of that size class is available then a new pool from the freepools list will be used for that & that pool will now be added to usedpools list & removed from freepools list.
</p>

 ![_config.yml]({{ site.baseurl }}/images/python/memory-management/pools.png)

### Blocks

<p>
  Pools are fragmented in smaller blocks of memory. All the blocks in a pool are of same size class. Blocks are the place where the actual objects are stored. Pools contain pointer to their free blocks. The freeblock pointer points to a singly linked list of free blocks of memory which is not always contiguous.
</p>

<p>
  Blocks can have 3 states:
  <ul>
    <li><b>untouched:</b> portion of memory that is not yet allocated for use</li>
    <li><b>free:</b> portion of memory that was previously allocated but it no longer contains relevant data</li>
    <li><b>allocated:</b> portion of memory that actually contains relevant data</li>
  </ul>
</p>

<p>
  Whenever the required memory exceeds the available free blocks the allocater will get some untouched blocks into the pool. Whenever the blocks become free they are added to the freeblock list at the front.
</p>

 ![_config.yml]({{ site.baseurl }}/images/python/memory-management/pools.png)



